import math, re, datetime, sysimport SWConfigclass Bullet():	def __init__(self, x, y, dir, world, owner):		self.x = x		self.y = y		self.world = world		self.dir = dir		self.owner = ownerclass Smiley():	def __init__(self, x, y, world, owner):		self.x = x		self.y = y		self.world = world		self.logic = None		self.owner = owner		def move(self, angleDeg):		self.x += math.cos(math.radians(angleDeg)) * SWConfig.SMILEY_SPEED		self.y += math.sin(math.radians(angleDeg)) * SWConfig.SMILEY_SPEED		if (self.x < 0):			self.x = 0		if (self.y < 0):			self.y = 0		if (self.x > self.world.width):			self.x = self.world.width		if (self.y > self.world.height):			self.y = self.world.height				return 1		def shoot(self, angleDeg):		self.world.bullets.append(Bullet(self.x + 5, self.y + 8, math.radians(angleDeg), self.world, self.owner))class World():	def __init__(self):		self.population = []		self.bullets = []		self.width = SWConfig.W_WIDTH		self.height = SWConfig.W_HEIGHT		self.state = {}		self.players = {}		self.colors = ['gold', 'green', 'red', 'blue', 'orange', 'black', 'pink', 'brown']	def add(self, x, y, owner):		if (owner not in self.players):			self.players[owner] = self.colors[0]			self.colors = self.colors[1:]		self.population.append(Smiley(x, y, self, self.players[owner]))		return self.players[owner]			def setLogic(self, index, logic):		logicFunc = 'def temp(me):\n' + re.sub('\n', '\n\t', re.sub('^', '\t', logic.replace('@', 'yield me.')))		exec(logicFunc, globals())		self.population[index].logic = temp(self.population[index]);		def clearLogic(self, index):		self.population[index].logic = None			def digest(self):		errors = {}		index = 0		for smiley in self.population:			if (smiley.logic != None):				try:					smiley.logic.__next__()				except StopIteration:					smiley.logic = None				except BaseException as ex:					errors[index] = str(type(ex))[8:-2] + ': ' + str(ex)					smiley.logic = None				finally:					pass						index += 1				newBullets = []		for objBullet in self.bullets:			objBullet.x += math.cos(objBullet.dir) * SWConfig.BULLET_SPEED			objBullet.y += math.sin(objBullet.dir) * SWConfig.BULLET_SPEED			if (objBullet.x >= 0 and objBullet.x <= self.width and objBullet.y >= 0 and objBullet.y <= self.height):			 newBullets.append(objBullet)			# collosion detection! :O					self.bullets = newBullets				return {'data_list': 					[{'pos' : (s.x / SWConfig.W_WIDTH, s.y / SWConfig.W_HEIGHT), 'owner' : s.owner} for s in self.population],				'errors': errors,				'bullets':					[{'pos' : (b.x / SWConfig.W_WIDTH, b.y / SWConfig.W_HEIGHT), 'owner' : b.owner} for b in self.bullets]}		def getState(self, lastUpdate = None, mes=''):		tNow = datetime.datetime.now()		lstCandidates = [dtDate for dtDate in self.state.keys() if (dtDate > lastUpdate if lastUpdate != None else True)]		if (len(lstCandidates) == 0 or (tNow - max(self.state.keys())).microseconds >= 400000 or ((tNow - max(self.state.keys())).seconds > 0)):			how_many_iterations = 25			if (lastUpdate != None and tNow.timestamp() - lastUpdate.timestamp() >= 500):				print('ooking!')				how_many_iterations = 10			self.state[tNow] = [self.digest() for i in range(how_many_iterations)] # 20? 25? less?			lstCandidates.append(tNow)					if (lastUpdate == None):			dtToReturn = max(self.state.keys())		else:			dtToReturn = min(lstCandidates)				return ({'when' : dtToReturn.timestamp() * 1000.0, 'what' : self.state[dtToReturn]})